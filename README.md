# import-export-shell-script

#! /bin/bash
#========================== ABOUT THIS SCRIPT =================================
: << AboutThisScript
Purpose: This script serves the purpose of exporting a dump of blocked and rejected transactions.
Initial Author: Kumar Neeraj
Date of Creation: June 9th, 2023
Dependencies: To ensure successful execution of this data extraction utility script, the following files must be present in the same directory:
runDataExtractionUtility.sh: The main script.
BackupTables.sql: SQL file for creating temporary tables.
cleanupTables.sql: SQL file for dropping temporary tables.
data.par: Parameter file containing a list of tables to be exported.
AboutThisScript
#========================== SCRIPT VARIABLES ==================================
# Data Extraction Utility Script Variable Settings for Unix
# WARNING: Please don't change anything here, since these variables were used in script.

PATH=/bin:/usr/bin:/etc:$ORACLE_HOME/bin:/usr/local/bin:$PATH;

CDPATH=;
# Clear the CDPATH variable, which affects the behavior of the `cd` command

Cmd="HotScan";

Exe=$(basename $0 .sh);

CmdPath="$(dirname $0)";

cd "$CmdPath";

CmdPath="$(pwd)";

tmpFile="/tmp/$(logname)$(tty|tr "/" "_")$(date +"%H%M%S%Y%m%d")$$";

TtyId=`tty | cut -d "/" -f3-`;
# Set the variable TtyId to the ID of the current terminal

ttySet=$(stty -g);

sys_date=$(date '+%Y%m%d%H%M%S')

log_folder=hslog_$sys_date

# Store the current terminal settings in the variable ttySet
export PATH CDPATH Cmd CmdPath TtyId tmpFile;
SQLScript="$CmdPath/$log_folder/$Exe.sql"; 
# Set data extraction SQL Script Name-Autogenerated by this script
SQLLog="$CmdPath/$log_folder/$Exe_$sys_date.sql.log"; 
# Set data extraction Log Name for sqlplus
ScriptLog="$CmdPath/$log_folder/DEU_Statistics_$sys_date.log";  
# This Script out put to Log file
HSVersion=V1.0;                      
# Set Current HotScan Version to Display
LogLines=3000;   
# An approximate, expected number of Output lines in $SQLLog


#======================= SCRIPT UTILITY FUNCTIONS =============================
# Trap SIGNAL Interrupts and Signal Handler.
function doExit
{
  rm -f $tmpFile $tmpFile.sql 2>/dev/null;
  case $1 in
    0) fLog "Exit $*: Exiting.";;
    *) fLog "$Cmd: Caught Interrupt Signal on $(date). dump export Cancelled. Exiting.";
       Say 20 2 "\033[0;1m%-73s\033[m" "$Cmd: Caught Interrupt Signal.  Data Extraction Cancelled.  Exiting.";;
  esac

  printf "\r\n\r\n\r\n\033[m";
  stty echo 2>/dev/null; 
  stty $ttySet 2>/dev/null;
  rm -rf $SQLScript;
  exit $1;
}

trap 'doExit 1' 1 2 3 4 5 6 7 8 10 11 12 13 14 15;
# Set up a signal trap to call the doExit function with an argument of 1 for specified signals


#______________________________________________________________________________

function fLog # Usage: fLog "FormatStr" "StringToLogInFile";
{ 
  fStr=$1; shift;
  printf "$(date +"%D %T") $fStr\n" $* >> $ScriptLog 2>/dev/null;
}

#______________________________________________________________________________
function initScreen  # Usage: initScreen "ScreenCaption";
{
  COLUMNS=""; LINES="";

  COLUMNS=$(stty -a| sed 's/ //g' | grep columns |tr ";" "\n" | tr "=" " " | grep columns | sed 's/columns//g');
  LINES=$(stty -a| sed 's/ //g' | grep rows |tr ";" "\n" | tr "=" " " | grep rows | sed 's/rows//g');

  [ -z "$COLUMNS" ] && COLUMNS=80;
  [ -z "$LINES" ] && LINES=24;

  if [ $COLUMNS -lt 80 -o $LINES -lt 24 ] 
  then printf "$Cmd: Terminal Windows size ${LINES}x$COLUMNS is not Sufficient. Please Maximize.\n";
       fLog "$Cmd: Terminal Windows size ${LINES}x$COLUMNS is not Sufficient. Please Maximize.";
       doExit 0;
  fi
  
  let StdScrX=COLUMNS-80;
  let StdScrX/=2;
  let StdScrY=LINES-24;
  let StdScrY/=2;
  [ $StdScrX -eq 0 ] && StdScrX=1;
  [ $StdScrY -eq 0 ] && StdScrY=1;

  # Form the WinScreen
  WinScr="\033[m\033[H\033[J";
  printf "${WinScr}$Cmd: Loading... Please wait...";

  let atY=StdScrY; 
  WinScr="$WinScr\033[$atY;${StdScrX}H$TopLine";
  let atY=StdScrY+1; 
  WinScr="$WinScr\033[$atY;${StdScrX}H$VertLine$(printf "\033[7m %-73s \033[m" "$*")$VertLine";
  let atY=StdScrY+2; 
  WinScr="$WinScr\033[$atY;${StdScrX}H$MidLine";
  let StdScrY+=2;
  y=0;
  while [ $y -lt 21 ]
  do let y+=1;
     let atY=StdScrY+y; 
     WinScr="$WinScr$(printf "\033[$atY;${StdScrX}H$VertLine %73s $VertLine" " ")";
  done
  let atY=StdScrY+y; 
  WinScr="$WinScr\033[$atY;${StdScrX}H$BotLine";
  let atY=StdScrY+1; let atX=StdScrX+1; 
  printf "$WinScr\033[$atY;${atX}H";

}
#______________________________________________________________________________

function Say  # Usage: Say atRow atCol  "trimStr" ...
{
   atY=$1; shift; atX=$1; shift;
   [ $atY -gt 20 ] && atY=20;
   [ -z "$StdScrY" ] && StdScrY=0;
   [ -z "$StdScrX" ] && StdScrX=0;
   let atY+=StdScrY; let atX+=StdScrX;
   fmtStr="$1" ; [ $# -ge 1 ] && shift;
   printf "\033[$atY;${atX}H$fmtStr" "$*" 2>/dev/null; 
}
#______________________________________________________________________________

function trimStr  # Usage: trimStr "StringToTrim";
{
  Len=$(echo "$1" | wc -c);
  if [ $Len -gt 50 ] 
  then
    let Len-=47;
    printf "..."; 
  else
    Len=1;
  fi
  printf "%-47s" "$(echo "$1" | cut -c$Len-)" 2>/dev/null;
}
#______________________________________________________________________________
function getTime {  # Usage : getTime VarToHoldTimeIn[HH:MM:SS]Format VarToHoldTimeInSeconds;
  hour=$(date +"%H");
  min=$(date +"%M");
  sec=$(date +"%S");
  eval $1="$hour:$min:$sec";

  let tmVal=10#$hour*3600;
  let tmVal+=10#$min*60;
  let tmVal+=10#$sec;
  eval $2=$tmVal;
}

#______________________________________________________________________________
function getTimeDiff # Usage: getTimeDiff tmStartInSeconds $tmEndInSeconds;
{
  tmStart=$1; tmEnd=$2; 
  # Now check if Ended on Next day, then Add one day!  Sec=24*60*60
  if [[ -n $tmEnd && -n $tmStart ]]; then
  [ $tmEnd -lt $tmStart ] && let tmEnd+=86400
fi

  let tmElapsed=tmEnd-tmStart;
  let hour=tmElapsed/3600;      
  let tmElapsed%=3600;
  let min=tmElapsed/60;    
  let tmElapsed%=60;
  let sec=tmElapsed;     

  printf "%02d:%02d:%02d"  $hour $min $sec;
}
#______________________________________________________________________________

function ProgressBar # Usage ProgressBar atRow atCol LogFileToWorkIn ApproxLenOfLogFile PromptString;
{
   atRow=$1;  
   atCol=$2;  
   LogFile=$3;  
   LogLines=$4; 
   ctrlRepl="$(printf "%31s" " ")";  
   Process=$(printf "%3.3s" $5);  

   Line=1;  
   PreSpBar=1;  
   PreLine=1;  
   Char="-";  

   [ -z "$StdScrY" ] && StdScrY=0; 
   [ -z "$StdScrX" ] && StdScrX=0;  

   while [ -f "$tmpFile" ]
   do {
      let PerCent=Line*100/LogLines;

      [ $PerCent -gt 100 ] && PerCent=99;

      let SpBar=PerCent/2;

      if [ $SpBar -ne $PreSpBar ]
      then {
           PreSpBar=$SpBar;

           [ $PerCent -eq 0 ] && PerCent=1;
           [ $SpBar -eq 0 ] && SpBar=1;

           Say $atRow $atCol "[\033[1;4;7m%${SpBar}s\033[27m" " ";
           
           let SpBar=50-SpBar;
           printf "%${SpBar}s\033[22;24m]" " ";
          
           [ $PerCent -ge 50 ] && printf "\033[7m";
           
           let atX=atCol+23; # at Middle
           Say $atRow $atX "\033[1;4m%3d%%\033[22;24;27m" $PerCent;

      } fi

      getTime EndedOn tmEnd;
      let atY=3+StdScrY; let atX=28+StdScrX;
      timeStr="\033[$atY;${atX}HRunning.. : $EndedOn";
      let atX=53+StdScrX;
      timeStr="$timeStr\033[$atY;${atX}HElapsed Time: ";
      timeStr="$timeStr$(getTimeDiff $tmStart $tmEnd)";
      let atX=atCol+54+StdScrX; 
      let atY=atRow+StdScrY;
      printf "$timeStr\033[$atY;${atX}H$Char \b\b" 2>/dev/null; 

      case $Char in
         "|") Char="/";;
         "/") Char="-";;
         "-") Char="\\";;
         "\\") Char="|";;
      esac
      # Animate the character used in the progress bar (rotating characters: -, /, \, |)
      Line=$(cat $LogFile | wc -l);

      if [ $Line -gt $PreLine ]
      then {
            let pbarAtY=atRow+3;
            let from=Line-10;
            [ $Line -lt 10 ] && from=1;

            while [ $from -le $Line ]
            do {
                LineEntry=$(head -$from $LogFile | tail -1 | tr "[$(printf "\001")-$(printf "\037")]" "$ctrlRepl");
                case $Process in
                  IMP*) LineEntry="$(echo "$LineEntry" | sed 's/\. \. importing t/From T/g')";;
                esac
                case "$LineEntry" in
                  *"IMP-"*"Warning"* | *"IMP-"*"Error"*)
                    LineEntry="$(printf "$VertLine %3.3s>\033[1m %-67.67s\033[22m  $VertLine" "$Process" "$LineEntry")" ;;
                  *) LineEntry="$(printf "$VertLine %3.3s> %-67.67s  $VertLine" "$Process" "$LineEntry")" ;;
                esac
                let logWinY=pbarAtY+StdScrY;
                printf "\033[$logWinY;${StdScrX}H$LineEntry";

                let pbarAtY+=1;
                let from+=1;
            } done

            PreLine=$Line;
      } fi

      [ $Line -ge $LogLines ] && let Line=LogLines-1;
      sleep 1;

   } done

   SpBar=50;  
   PerCent=100;
   Say $atRow $atCol "[\033[7m%26s%%" "100";
   printf "%23s\033[27m]      " " ";

   Line=$(cat $LogFile | wc -l);

   let from=Line-10;
   [ $Line -lt 10 ] && from=1;
   let pbarAtY=atRow+3;

   while [ $from -le $Line ]
   do {
      LineEntry=$(head -$from $LogFile | tail -1 | tr "[$(printf "\001")-$(printf "\037")]" "$ctrlRepl");
      Say $pbarAtY 0 "$VertLine $Process> %-68.68s $VertLine" "$LineEntry";
      let pbarAtY+=1;
      let from+=1;
   } done
}

#______________________________________________________________________________

#========================== DUMP EXPORT FUNCTIONS ===============================
function setDBConnInfo {
  OraToUser="$1";
  OraPasswd="$2";
  OraTNSService="$3";
  
  SQLPLUS="/$(type sqlplus 2>/dev/null | cut -d "/" -f2-)";  # find the sqlplus...
  [ "$SQLPLUS" = "/" ] && SQLPLUS="[_Not_Found_]";

  [ -z "$OraTNSService" ] && OraTNSService=$(echo $ORACLE_SID);

  # Create the complete connection string by appending OraTNSService to OraPasswd
  OraPasswd=$OraPasswd@$OraTNSService;

  # Create a temporary SQL file with the content "exit;" for testing the database connection
  printf "exit; " > $tmpFile.sql;

  # Test the database connection using sqlplus
  if ! sqlplus -L "$OraToUser/$OraPasswd" @$tmpFile.sql >$tmpFile 2>&1; then
    # Connection failed, retrieve the error message and display an error
    InitMsg="$(grep "ORA-" $tmpFile).";
    printf "$Cmd: Connection with Oracle Failed. $InitMsg\n";  
    rm -f $tmpFile $tmpFile.sql;
    exit 1;
  fi

  # Connection successful, remove the temporary files
  rm -f $tmpFile $tmpFile.sql;
   
  
}

#______________________________________________________________________________

function getDBConnInfo {
  initScreen "HotScan Data Extraction Utility V1.0 [Press Ctrl+C to Cancel]"
  fLog "$Cmd: Data Extraction Utility V1.0 Started on: $(date)"
  LocationInput="TRB,GFT,PPF,SAA,PEP"
  SQLBanner=$(sqlplus -V 2>/dev/null)
  SQLBanner=$(echo $SQLBanner)

  SQLPLUS="/$(type sqlplus 2>/dev/null | cut -d "/" -f2-)"  # find the sqlplus...
  [ "$SQLPLUS" = "/" ] && SQLPLUS="[_Not_Found_]"

  if [ -z "$SQLBanner" ]; then
    # Oracle environment not found
    Say 7 2 "$Cmd: Error: Environment variable ORACLE_HOME is not set or Invalid."
    Say 9 2 "Unable to find Oracle Home and its utilities."
    Say 11 2 "Current value of \033[1mORACLE_HOME=$ORACLE_HOME\033[22m"
    Say 19 0 "$MidLine"
    Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Unable to start due to Oracle Environment not found."
    doExit 0
  fi
 
  # Get DB Connection Details from User
  
  fLog "[ STEP 1 of 4 ] * Getting DB Connection Details from User: $(logname)@$(hostname) from Terminal: $(tty)..."
  Say 1 2 "%73s" "[ STEP 1 of 4 ] * Provide DB Connection Details"
  Say 2 2 "$SQLBanner"
  Say 3 0 "$MidLine"
  Say 5 2 "Oracle DB UserName : "
  Say 6 2 "Oracle DB Password : "
  Say 7 2 "TNS Service Name   : "
  Say 9 2 "Source Schema Name     : "
  Say 10 2 "Location Id            :  $LocationInput"
  Say 11 2 "From Date (dd/mm/yyyy) : "
  Say 11 28 "DD: "
  Say 11 35 "MM: "
  Say 11 42 "YYYY: "
  Say 12 2 "To Date   (dd/mm/yyyy) : "
  Say 12 28 "DD: "
  Say 12 35 "MM: "
  Say 12 42 "YYYY: "
  Say 15 2 "Oracle Home Path       : $(trimStr "$ORACLE_HOME")"
  Say 16 2 "SQL*Plus Utility       : $(trimStr "$SQLPLUS")"
  Say 19 0 "$MidLine"
  InitMsg="Please Enter Oracle DB User Name to start Data Extraction."
  while :; do
    Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: $InitMsg"
    OraTNSService=""
    Say 5 24 "%50s" " "
    Say 5 24 "\033[4;1m"
    read OraToUser
	username="${OraToUser%%@*}"
	Say 9 28 "$username"
    printf "\033[m"

    case $OraToUser in
      *@*) OraTNSService=$(echo "$OraToUser" | cut -d "@" -f2)
           OraToUser=$(echo "$OraToUser" | cut -d "@" -f1)
    esac

    Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: Please Enter Oracle DB Password of User \`$OraToUser'."
    Say 6 24 "%50s" " "
    Say 6 24 "\033[4;1m"
    OraPasswd=""
    stty  -echo ixoff ixon ixany -icrnl -brkint -icanon min 0 time 1
    while :; do
      while :; do InputChar=$(head -1); [ -z "$InputChar" ] || break; done
      [ "`printf "\015"`" = "$InputChar" ] && break
      OraPasswd="$OraPasswd$InputChar"
      chr=$(echo $InputChar|wc -c); while [ $chr -gt 1 ]; do printf "*"; let chr-=1; done
    done
    printf "\033[m"
    stty $ttySet
    Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: Please Enter Oracle TNS Service Name to Connect with."
    Say 7 24 "%50s" " "
    Say 7 24 "\033[4;1m"
    [ -z "$OraTNSService" ] && read OraTNSService || printf "$OraTNSService\n"
    printf "\033[m"
    Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: Verifying Oracle Connectivity.. Please wait.."
    # If TNS Service is set, append with Password.
    [ -z "$OraPasswd" ] && OraPasswd="NULL"
    [ -z "$OraTNSService" ] && OraTNSService=$(echo $ORACLE_SID)
    [ -z "$OraTNSService" ] && OraTNSService="[_Not_Found_]" || OraPasswd="$OraPasswd@$OraTNSService"
    Say 7 24 "%50s" " "
    Say 7 24 "\033[4;1m$OraTNSService\033[m"

    printf "exit; " > $tmpFile.sql

    if sqlplus -L "$OraToUser/$OraPasswd" @$tmpFile.sql >$tmpFile 2>&1; then
      break
    else
      InitMsg="Failed: $(grep "ORA-" $tmpFile)."
    fi
  done
  rm -f $tmpFile.sql $tmpFile
  InitMsg="Please Enter Source Schema Name "
  while :; do
    Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: $InitMsg"
	Say 9 28 "%30s" " "
    Say 9 28 "\033[4;1m"
    read -e -i "$username" SourceSchemaName
    printf "\033[m"

    if [ -n "$SourceSchemaName" ]; then
      break  
    else
      Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Source Schema Name cannot be empty. Please try again."
      sleep 1  
    fi
  done

#=====================================location id====================================
InitMsg="Please Enter Location Id (Default: TRB,GFT,PPF,SAA,PEP)"
Say 20 2 "\033[1m%-73.73s\033[22m" "$Cmd: $InitMsg"
while :; do
  Say 10 28 "%30s" " "
  Say 10 28 "\033[4;1m"
  read -e -i "$LocationInput" LocationId
  LocationId=$(echo "$LocationId" | tr '[:lower:]' '[:upper:]')
  if [ -z "$LocationId" ]; then
    LocationId="TRB,GFT,PPF,SAA,PEP"
  fi
  # Validate if LocationId ends with a comma
  if [[ $LocationId == *, ]]; then
    Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid Format. Please enter a Location without a trailing comma."
    continue
  fi
  IFS=',' read -ra Locations <<< "$LocationId"
#create a separate array without pep location
LocationsArrayWithoutPEP=()
for loca in "${Locations[@]}"; do
  if [[ $loca != "PEP" ]]; then
    LocationsArrayWithoutPEP+=("$loca")
  fi
done
  valid=true
  for loc in "${Locations[@]}"; do
    if ! [[ $loc =~ ^[A-Za-z]{2,3}$ ]]; then
      valid=false
      break
    fi
  done

  if $valid; then
    break
  else
    Say 20 2 "\033[1m%-73s\033[m" "Invalid Format. Please Enter Location in 2 or 3 Alphabets Separated By Comma."
  fi
done

LocationString=$(IFS=','; printf "'%s'," "${Locations[@]}")   #surround all locations in single quote
LocationString=${LocationString%,}  #remove the trailing comma
LocationString+=",'ALL'"  #add one more element 'ALL' in the locationString

LocationStringWithoutPEP=$(IFS=','; printf "'%s'," "${LocationsArrayWithoutPEP[@]}")   
LocationStringWithoutPEP=${LocationStringWithoutPEP%,}
LocationStringWithoutPEP+=",'ALL'" 

ConfirmLocString=$(IFS=','; echo "${Locations[*]}")
#=====================from date==========================

  FromDay=""
  FromMonth=""
  FromYear=""
  opt="[Optional]"
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter From Day (DD) Between 01 and 31 $opt. "
  while :; do
  Say 11 28 "%3s" " "
  Say 11 28 "\033[4;1m"
  Say 11 28 "DD: "
  read -r -n 2 FromDay

  # Check if day is not a digit or if it's greater than 31
  if [[ -n $FromDay ]] && ! [[ $FromDay =~ ^[0-9]+$ ]] || ((10#$FromDay > 31 )); then
    Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid day. Please Enter a Value Between 01 and 31 $opt."
  else
    break  
  fi
done
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter From Month (MM) Between 01 and 12 $opt. "
  while :; do
  Say 11 35 "%3s" " "
  Say 11 35 "\033[4;1m"
  Say 11 35 "MM: "
  read -r -n 2 FromMonth
  # Check if month is between 1 and 12
if [[ -n $FromMonth ]] && ! [[ $FromMonth =~ ^[0-9]+$ ]] || ((10#$FromMonth > 12 )); then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid month. Please Enter a Value Between 01 and 12 $opt."
  else
  break
fi
done
  while :; do
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter Valid From Year(YYYY) $opt. "
  Say 11 42 "%30s" " "
  Say 11 42 "\033[4;1m"
  Say 11 42 "YYYY: "
  read -n 4 FromYear
  
  if [[ -n $FromYear ]] && ! [[ $FromYear =~ ^[0-9]+$ ]] ; then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid Year (YYYY) $opt."
  else
  break
fi
done

FromDate=""
if [[ -n "$FromDay" && -n "$FromMonth" && -n "$FromYear" ]]; then
  ConfirmFromDate="$FromDay/$FromMonth/$FromYear"
  FromDate="$FromYear$FromMonth$FromDay"
  ReplaceFromDate="'$FromYear$FromMonth$FromDay 00:00:00'"
fi
#====================================to date===================================
  while :; do 
  ToDay=""
  ToMonth=""
  ToYear=""
  while :; do
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter To Day (DD) Between 01 and 31 $opt. "
  Say 12 28 "%7s" " "
  Say 12 28 "\033[4;1m"
  Say 12 28 "DD: "
  read -r -n 2 ToDay
  
  if [[ -n $ToDay ]] && ! [[ $ToDay =~ ^[0-9]+$ ]] || ((10#$ToDay > 31 )); then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid day. Please Enter a Value Between 01 and 31 $opt."
  else
    break 
  fi
  done
  
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter To Month (MM) Between 01 and 12 $opt. "
  while :; do
  Say 12 35 "%7s" " "
  Say 12 35 "\033[4;1m"
  Say 12 35 "MM: "
  read -r -n 2 ToMonth
  # Check if month is between 1 and 12
if [[ -n $ToMonth ]] && ! [[ $ToMonth =~ ^[0-9]+$ ]] || ((10#$ToMonth > 12 )); then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid month. Please Enter a Value Between 01 and 12 $opt."
  else
  break
fi
done

  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Enter To Year(YYYY) $opt. "
  while :; do
  Say 12 42 "%15s" " "
  Say 12 42 "\033[4;1m"
  Say 12 42 "YYYY: "
  read -n 4 ToYear
  
  if [[ -n $ToYear ]] && ! [[ $ToYear =~ ^[0-9]+$ ]] ; then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Invalid Year (YYYY) $opt."
  else
  break
fi 	 
done
# Validation for From Date should be less than To Date
if [ "$FromYear" -gt "$ToYear" ] ||
   [ "$FromYear" -eq "$ToYear" -a "$FromMonth" -gt "$ToMonth" ] ||
   [ "$FromYear" -eq "$ToYear" -a "$FromMonth" -eq "$ToMonth" -a "$FromDay" -gt "$ToDay" ]; then
  Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Please Ensure From date is Less Than To date $opt."
  sleep 4
else
  break
fi
done
ToDate=""
if [[ -n "$ToDay" && -n "$ToMonth" && -n "$ToYear" ]]; then
  ToDate="$ToYear$ToMonth$ToDay"
  ReplaceToDate="'$ToYear$ToMonth$ToDay 11:59:59'"
  ConfirmToDate="$ToDay/$ToMonth/$ToYear"
fi
}

#______________________________________________________________________________

function confirmDBConnInfo {
  stty -echo;  

  case $1 in
    DONE)
      initScreen "HotScan V1.0 Data Extraction Completed. - Thank you.";
      fLog "$Cmd: Please check appropriate log files for any clarification.";
      Say  1 2 "Please check appropriate log files for any clarification.";;
    *)
      fLog "[ STEP 1 of 4 ] * Getting Confirmation on following DB Connection Details";
      initScreen "HotScan 1.0 Data Extraction Utility. [Press Ctrl+C to Cancel]";
      Say  1 2 "%73s" "[ STEP 2 of 4 ] * Please Confirm following DB Connection Details";;
  esac

  # Display DB connection details on the screen
  Say  2 0 "$MidLine";
  Say 19 0 "$MidLine";
  Say  3 2 "Oracle DB UserName : $OraToUser"
  Say  4 2 "Oracle DB Password : ********"
  Say  5 2 "TNS Service Name   : $OraTNSService"
  Say  6 2 "Source Schema Name : $SourceSchemaName"
  Say  7 2 "Location Id        : $ConfirmLocString"
  Say  9 2 "From Date(dd/mm/yyyy) : $ConfirmFromDate"
  Say 10 2 "ToDate   (dd/mm/yyyy) : $ConfirmToDate" 

  case $1 in
    DONE)
      
      getTime tmStatRunEndedOn tmRunEndSec; 
      Say 13 2 "Time Statistics for      Started at        Completed at      Elapsed Time"; 
      Say 15 2 "  * Extracting Data   $tmStatImpStartedOn          $tmStatImpEndedOn          ";
      getTimeDiff $tmImpStartSec $tmImpEndSec;

      Say 16 2 "  * Extracting Data   $tmStatMigStartedOn          $tmStatMigEndedOn          "
      getTimeDiff $tmMigStartSec $tmMigEndSec; 
      printf "\nTime Statistics for      Started at        Completed at      Elapsed Time"  >> $ScriptLog;
      printf "\n  * Extracting Data  $tmStatImpStartedOn          $tmStatImpEndedOn          " >> $ScriptLog;
      getTimeDiff $tmImpStartSec $tmImpEndSec >> $ScriptLog;

      printf "\n  * Extracting Data   $tmStatMigStartedOn          $tmStatMigEndedOn          " >> $ScriptLog;
      getTimeDiff $tmMigStartSec $tmMigEndSec >> $ScriptLog; 
      printf "\n\n" >> $ScriptLog; 

      
      fLog "$Cmd: Following Details were used for the Data Extraction:";;
    *)
      
      Say 13 2 "Oracle Home Path   : "; trimStr "$ORACLE_HOME"
      
      Say 15 2 "SQL*Plus Utility   : "; trimStr "$SQLPLUS";;
  esac

  # Log all the DB connection details
  fLog "  * Oracle DB UserName : $OraToUser"
  fLog "  * Oracle DB Password : ********"
  fLog "  * TNS Service Name   : $OraTNSService"
  fLog "  * Source Schema Name : $SourceSchemaName"
  fLog "  * Location ID        : $ConfirmLocString"
  fLog "  * From Date          : $ConfirmFromDate"
  fLog "  * To Date            : $ConfirmToDate"
  fLog "  * Oracle Home Path   : $ORACLE_HOME"
  fLog "  * SQL*Plus Utility   : $SQLPLUS \n"

  case $1 in
    DONE)
      
      fLog "HotScan $HSVersion - Temporary Tables Created Successfully on $(date).";
      rm -rf $SQLScript 2>/dev/null;
      Say 20 2  "\033[1m%-73.73s\033[m" "$Cmd: Temporary Tables Creation Completed.";
      doExit 0;;
  esac
  
  case $1 in
    WAIT)
      Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Press ENTER to continue (CTRL+C to Cancel)...";
      Say 20 18; read ans;;
    *)
      
      Say 20 2 "\033[1m%-73s\033[m" "$Cmd: Preparing to Auto-Start Temporary Table Creation...";
      sleep 5;
  esac
}
#_________________________________________________________________________________________________________________
function startTempTableCreation 
{
Exit=0;
  initScreen "HotScan Data Extraction Utility V1.0 [Please Don't Interrupt]"
  Say  1 2 "%73s" "[ STEP 2 of 4 ] * Creating Temporary Tables...";
  fLog "[ STEP 2 of 4 ] * Creating Temporary Tables...";
  Say  2 0 "$MidLine";
  Say  7 0 "$MidLine";
  Say 19 0 "$MidLine";
  
  Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Please wait, while Creating Temporary Tables...";
     
       [ -z "$OraFromUser" ] && OraFromUser="$OraToUser";

       getTime StartedOn tmStart; tmStatImpStartedOn=$StartedOn; tmImpStartSec=$tmStart;
       Say  3 2  "Started at: $StartedOn"
       Say  3 28 "Running at: $StartedOn"
       Say  3 53 "Elapsed Time: 00:00:00"
	   LogLines=3000;
	   > $tmpFile;
  SQLLog=""$CmdPath"/$log_folder/"$Exe"_"$sys_date".sql.log";
  ( sleep 2; ProgressBar 5 13 $SQLLog $LogLines SQL; ) &
  
  ### [ Creating Temp Tables ] ####
  sql_file="BackupTables.sql"
  tmp_file="modifiedBackupTables.sql"
  cp BackupTables.sql modifiedBackupTables.sql
  sed -e "s/\$ListOfLocations/$LocationString/g" -e "s/\$LocationStringWithoutPEP/$LocationStringWithoutPEP/g" "$sql_file" > "$tmp_file" 
  
  
DateTimeFormate=""
if [[ -z $FromDate && -z $ToDate ]]; then
DateTimeFormate=" "
elif [[ -z $FromDate && ! -z $ToDate ]]; then
DateTimeFormate="AND DATETIME<=$ReplaceToDate"
elif [[ ! -z $FromDate && -z $ToDate ]]; then
DateTimeFormate="AND DATETIME>=$ReplaceFromDate"
else
DateTimeFormate="AND DATETIME>=$ReplaceFromDate AND DATETIME<=$ReplaceToDate"
fi

  #$SQLPLUS -S "$OraToUser/$OraPasswd" @modifiedBackupTables.sql $FromDate $ToDate $LocationStringWithoutPEP &> $SQLLog 
  $SQLPLUS -S "$OraToUser/$OraPasswd" @"$tmp_file" "$DateTimeFormate" >> $SQLLog 2>&1
  rm -rf $SQLScript
  fLog "[ STEP 2 of 4 ] * Temporary Tables Created Successfully...\n";
  Say  1 2 "%73s" "[ STEP 2 of 4 ] *Temporary Tables Created...";
  Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Temporary Tables Created Successfully...";  
  rm "$tmp_file"
  sleep 2;
 
}
#______________________________________________________________________________

function ExportWithPAR
{
  let LogLines=400
  initScreen "HotScan Data Extraction Utility V1.0 [Please Don't Interrupt]"
  Say  1 2 "%57s" "[ STEP 3 of 4 ] * Data Extraction Started...";
  fLog "[ STEP 3 of 4 ] * Starting Dump Export...";
  Say  2 0 "$MidLine";
  Say  7 0 "$MidLine";
  Say 19 0 "$MidLine";

  Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Please wait, Data Extraction is in Progress...";
  
  EXPDPSQL="/$(type expdp 2>/dev/null | cut -d "/" -f2-)";  
  [ "$EXPDPSQL" = "/" ] && EXPDPSQL="[_Not_Found_]";
  [ "${EXPDPSQL: -1}" == ")" ] && EXPDPSQL=${EXPDPSQL::-1};
  

  fLog "$Cmd: Starting Dump Export Utility : $EXPDPSQL $OraToUser/*******@$OraTNSService";

  Say  3 2  "Started at: $StartedOn"
  Say  3 28 "Running at: $StartedOn"
  Say  3 53 "Elapsed Time: 00:00:00"
  > $tmpFile;
  #SQLLog=""$CmdPath"/$log_folder/"$Exe"_"$FromDate"to"$ToDate".sql.log";  
   SQLLog=""$CmdPath"/$log_folder/"$Cmd"_"$sys_date".dmp.log"  
  ( sleep 2; ProgressBar 5 13 $SQLLog $LogLines SQL; ) &
     Par="data.par"
	 Say  1 2 "%57s" "[ STEP 3 of 4 ] * Dump Export is in Progress...";
		 $EXPDPSQL "PARFILE=$Par" "USERID="$OraToUser/$OraPasswd"" "dumpfile="$Cmd""_""$sys_date"" >> $SQLLog 2>> $SQLLog
		 Say  1 2 "%57s" "[ STEP 3 of 4 ] * Dump Export Completed...";
		 fLog "[ STEP 3 of 4 ] * Dump "$dumpfile" Exported. Please Check Log: $SQLLog \n";

  sleep 3;
  Say  1 2 "\033[1m%-73.73s\033[m" "[ STEP 4 of 4 ] Dropping Temporary Tables.";
  fLog "[ STEP 4 of 4 ] * Dropping Temporary Tables...";
  Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Please Wait While Dropping Temporary Tables.."
  SQLLog=""$CmdPath"/$log_folder/"$Exe"_"$sys_date".sql.log";
  $SQLPLUS -S "$OraToUser/$OraPasswd" @cleanupTables.sql >> $SQLLog 2>&1
  #$SQLPLUS -S "$OraToUser/$OraPasswd" @cleanupTables.sql > /dev/null 2>&1
  Say 20 2 "\033[1m%-73.73s\033[m" "$Cmd: Temporary Tables Dropped Successfully..."
  fLog "[ STEP 4 of 4 ] * Temporary Tables Dropped Successfully... \n";
  fLog "  * SQL Script Log file    : $SQLLog \n"
  sleep 2;
  Say  1 2 "\033[1m%-73.73s\033[m" "$Cmd: Data Extraction Completed Please Check Logs.";
  Say  3 2  "Started at: $StartedOn"
  Say  3 28 "Completed : $EndedOn"
  Say  3 53 "Elapsed Time: $timeDiff"; 
  
  getTime EndedOn tmEnd; tmStatMigEndedOn=$EndedOn; tmMigEndSec=$tmEnd
  rm -f $tmpFile; sleep 3;
  timeDiff=$(getTimeDiff $tmStart $tmEnd);
  fLog "$Cmd: SQLPlus & EXPDP Time Statistics :";
  fLog "  * Started at   : $(date +%Y:%m:%d ) $StartedOn";
  fLog "  * Completed at : $(date +%Y:%m:%d ) $EndedOn";
  fLog "  * Elapsed Time : $timeDiff \n";
  fLog "$Cmd: Data Extraction Utility $HSVersion Ended on: $(date).";
  Say 20 2 "\033[1m%-73.73s\033[m" "Thanks For Using $Cmd Data Extraction Utility V1.0..."
}

#______________________________________________________________________________

function Main {
  getTime tmStatRunStartedOn tmRunStartSec;  

  [ -z "$TESTRUN" ] || Cmd="TESTRUN";  

  if ! [ -d "$ORACLE_HOME" ]  
  then
    printf "$Cmd: Oracle Home Not Set or Invalid. ORACLE_HOME=$ORACLE_HOME\n";  
    exit 1;  
  fi

  if ! [ -r /tmp -a -w /tmp -a -x /tmp ]  
  then
    printf "$Cmd: Temporary folder \`/tmp': Permission Denied. (FAP: $(ls -ld /tmp | awk -F" " '{ print $1; }'))\n";  
    printf "$Cmd: Please contact your Unix Administrator.\n";  
    exit 1;  
  fi
  chmod u+rwx . 2>/dev/null;  

  if [ -r . -a -w . -a -x . ]  
  then
    {
      ls -ld $log_folder >/dev/null 2>&1;  
      
      mkdir $log_folder 2>/dev/null 
      
      HSVersion="V1.0"  
      LogLines=${TOTAL_SQLLOG_LINES:-1680};  

      expr $LogLines \* 1 >/dev/null 2>&1 || LogLines=1680;  

      echo "-- AutoGenerated Script for HotScan $HSVersion dated on $(date)" > $SQLScript  
      echo "-- SQL_SCRIPTS=$SQL_SCRIPTS" >> $SQLScript  

      for sqlfile in $SQL_SCRIPTS  
      do
        {
          if [ -f $sqlfile -a -r $sqlfile ]; then
            echo "PROMPT runDataExtractionUtility.sh: Running Script $sqlfile" >> $SQLScript;  
            echo "@$sqlfile" >> $SQLScript  
          else
            printf "$Cmd: SQL Script $sqlfile could not be loaded. "
            ! [ -e $sqlfile ] && printf "File not found.\n" || printf "Permission denied.\n";
            exit 1;  
          fi
        }
      done

      if [ "$TERM" = "vt100" ]
      then
        TopLine="\033(0\017lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk\033(B\016\017";
        MidLine="\033(0\017tqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqu\033(B\016\017";
        BotLine="\033(0\017mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj\033(B\016\017";
        VertLine="\033(0\017x\033(B\016\017"
      else
        TopLine=".---------------------------------------------------------------------------.";
        MidLine="|---------------------------------------------------------------------------|";
        BotLine="|___________________________________________________________________________|";
        VertLine="|"
      fi
       
	  # Validate the presence of required files
  if [ ! -f "BackupTables.sql" ] || [ ! -f "cleanupTables.sql" ] || [ ! -f "data.par" ]; then
  echo "╔═══════════════════════╗"
echo "║                       ║"
echo "║   Required files      ║"
echo "║   are missing.        ║"
echo "║   Exiting.            ║"
echo "║                       ║"
echo "╚═══════════════════════╝"

    doExit 1
  fi 
	  
      > $ScriptLog;  
      
      case $# in 
        0) getDBConnInfo;        
           confirmDBConnInfo WAIT;  
           ;; 
        *) setDBConnInfo "$@";  
           confirmDBConnInfo START;  
           ;; 
      esac
      startTempTableCreation;
      ExportWithPAR;
      rm -rf $SQLScript  
    }
  else
    {
      printf "$Cmd: Insufficient Permission on Current Directory.\n";
      printf "$Cmd: $(pwd): Permission Denied. (FAP: $(ls -ld | awk -F" " '{ print $1; }')).\n";
      exit 1;  
    }
  fi;
}

#______________________________________________________________________________
# Usage: $Cmd [ <OraUserName> <OraPasswd> <OraTNS> <SourceSchemaName> <FromDate> <ToDate> ]
Main "$@" ;  # Main Script
doExit 0;
